def doGet(request, session):
	# Web Dev Resource: /google/oauth/redirect
	# HTTP Method: doGet
	"""
	Google OAuth2 Redirect / Callback Endpoint
	
	This endpoint is invoked by Google after the user approves (or denies)
	the OAuth authorization request.
	
	Expected redirect format:
		REDIRECT_URI?code=XXXX&state=YYYY
	"""
	
	from google.auth import GoogleOAuthClient
	
	logger = system.util.getLogger("GoogleOAuthRedirect")
	
	# Extract query parameters delivered to the WebDev resource.
	# `params` contains OAuth2 values such as code, state, and error.
	params = request.get("params", {})
	logger.info("OAuth redirect params: %s" % params)
	
	# Extract OAuth parameters from the query string.
	code  = params.get("code")
	error = params.get("error")
	state = params.get("state")
	
	# The actual servlet response object provided by Ignition WebDev.
	# It can be None when running in certain contexts.
	servletResponse = request.get("servletResponse")
	
	# ------------------------------------------------------------
	# 0) Retrieve which UDT root tag should be updated
	# ------------------------------------------------------------
	# The root_tag (e.g., "[default]Google") was stored in session
	# by the start endpoint (/google/oauth/start). This makes the
	# redirect endpoint reusable for multiple accounts/UDTs.
	root_tag = session.get("google_oauth_root_tag", None)
	logger.info("Redirect root_tag=%s" % root_tag)
	
	# If the start endpoint was not executed, the session will be missing.
	if not root_tag:
		return {"html": "<h2>Error: No root_tag in session</h2>"}
	
	# ------------------------------------------------------------
	# 1) Normalize parameters
	# Google sometimes returns multi-value fields as lists.
	# Convert them to single values for consistency.
	# ------------------------------------------------------------
	if isinstance(code, (list, tuple)):
		code = code[0]
	if isinstance(state, (list, tuple)):
		state = state[0]
	
	# ------------------------------------------------------------
	# 2) Google returned an OAuth error
	# Example: access_denied, disallowed_useragent, etc.
	# ------------------------------------------------------------
	if error:
		if servletResponse is not None:
			servletResponse.setStatus(400)
		html = (
			"<html><body>"
			"<h2>Google OAuth Error</h2>"
			"<p>error: %s</p>"
			"</body></html>" % error
		)
		return {"html": html}
	
	# ------------------------------------------------------------
	# 3) Missing authorization code
	# This indicates the user was not redirected correctly or the 
	# Google auth flow was blocked/cancelled.
	# ------------------------------------------------------------
	if not code:
		if servletResponse is not None:
			servletResponse.setStatus(400)
		html = (
			"<html><body>"
			"<h2>Missing authorization code.</h2>"
			"<p>Required query parameter 'code' was not found.</p>"
			"</body></html>"
		)
		return {"html": html}
	
	# ------------------------------------------------------------
	# 4) Validate OAuth state parameter (SECURITY CHECK)
	#
	# State protects against CSRF. The value must match the one
	# generated by /google/oauth/start and stored in session.
	#
	# If it does not match, this request might be forged.
	# ------------------------------------------------------------
	expected_state = session.get("google_oauth_state", None)
	
	if not state or not expected_state or state != expected_state:
		logger.warn("Invalid or missing OAuth state. state=%s, expected=%s" % (state, expected_state))
		if servletResponse is not None:
			servletResponse.setStatus(400)
		html = (
			"<html><body>"
			"<h2>Invalid OAuth state.</h2>"
			"<p>Security check failed. Please retry the login process.</p>"
			"</body></html>"
		)
		return {"html": html}
	
	# ------------------------------------------------------------
	# 5) Consume the state value (One-Time Token)
	#
	# OAuth state must never be reused. Removing it from the session
	# ensures replay attacks cannot succeed.
	# ------------------------------------------------------------
	try:
		del session["google_oauth_state"]
	except KeyError:
		pass
	
	# ------------------------------------------------------------
	# 6) Normalize code again (Google sometimes returns arrays)
	# ------------------------------------------------------------
	if isinstance(code, (list, tuple)):
		code = code[0]
	
	# Initialize the OAuth client using the resolved root_tag.
	client = GoogleOAuthClient(root_tag)
	
	try:
		# --------------------------------------------------------
		# 7) Exchange authorization code for tokens
		#
		# Google returns:
		#   - access_token  (short-lived)
		#   - refresh_token (long-lived; only returned on first consent)
		#
		# The method writes the tokens into your UDT automatically.
		# --------------------------------------------------------
		access_token, refresh_token = client.exchange_code_for_tokens(code)
		
		logger.info(
			"Google OAuth tokens updated successfully. "
			"access_token length=%d, has_refresh=%s"
			% (len(access_token or ""), bool(refresh_token))
		)
	
		if servletResponse is not None:
			servletResponse.setStatus(200)
	
		# User-facing HTML shown in the browser tab after successful linking.
		html = (
			"<html><body>"
			"<h2>Google account linked successfully.</h2>"
			"<p>You may now close this window and return to Ignition.</p>"
			"</body></html>"
		)
		return {"html": html}
	
	# ------------------------------------------------------------
	# 8) Handle any internal server-side exception
	# ------------------------------------------------------------
	except Exception, e:
		logger.error("Error in Google OAuth redirect handler: %s" % e)
		if servletResponse is not None:
			servletResponse.setStatus(500)
		html = (
			"<html><body>"
			"<h2>Internal error in OAuth redirect.</h2>"
			"<p>Please check the Ignition gateway logs for details.</p>"
			"</body></html>"
		)
		return {"html": html}